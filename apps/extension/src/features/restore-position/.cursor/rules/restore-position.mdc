---
description: Position Restore Feature - History and Dialog
globs:
  - "**/restore-position/**/*.ts"
  - "!**/*.test.ts"
alwaysApply: false
---

# Position Restore Feature

## File Structure

```
restore-position/
  dialog.ts        <- Dialog controller (state, events, logic)
  history.ts       <- Position history management
  index.ts         <- Public API and feature initialization
  ui/
    dialog.ts      <- Dialog DOM creation (elements, builders)
    styles.ts      <- CSS styles for the dialog
```

### Separation of Concerns

- **`dialog.ts`** (controller): Module-level state, event handling, keyboard shortcuts, dialog lifecycle
- **`ui/dialog.ts`** (view): Pure DOM creation functions (`createDialogDOM`, `createPositionItem`, `buildPositionList`)
- **`ui/styles.ts`**: CSS-in-JS style definitions

The controller imports from `./ui/dialog` and orchestrates the dialog lifecycle while delegating DOM creation to the UI module.

## Position History Algorithm

### State Management
- `positionHistory`: Array of { time, label, savedAt } entries
- `loadTimePosition`: Position when video first loaded (captured after initial resume)
- `userSavedPosition`: User-saved position via S key (single entry, overwrites previous)
- `SEEK_MAX_HISTORY`: Maximum entries to keep (3)
- `SEEK_MIN_DIFF_SECONDS`: Minimum difference between saved positions (15 seconds)

### Debounce Logic for Seeks
- `SEEK_DEBOUNCE_MS`: 5 seconds window for grouping rapid seeks
- Only the position before the FIRST seek in a sequence is saved
- **Keyboard/button seeks** use debouncing via `debouncedSavePosition()` - prevents rapid key presses from filling history
- **Timeline clicks** are NOT debounced - each click is a deliberate user action that should be recorded
- Flag `isKeyboardOrButtonSeek` distinguishes seek sources (keyboard seeks are recorded explicitly via `recordBeforeSeek()`, timeline seeks are recorded via `seeking` event)
- Debounce window uses inclusive boundary: `now - lastSeekTime <= SEEK_DEBOUNCE_MS`

### Position Recording Rules (for automatic history saves)
1. Don't save positions < 15 seconds into video
2. Don't save if too close to load time position  
3. Don't save if too close to user saved position
4. Don't save if too close to ANY existing position in history
5. Blocked saves (due to rules 1-4) do NOT start a debounce window

Note: User saved position (S key) bypasses all these rules and always saves.

## Ready State Management

The ready state determines when position tracking is enabled. Uses an **event-driven approach** with fallback timeout.

### Primary Triggers

Ready state is triggered by video events:
- `canplay` - video can play at current position
- `playing` - video is actively playing
- `loadeddata` - first frame of video loaded
- `seeked` - seek operation completed (calls `handleVideoReady` if not yet ready)

### Fallback Timeout

If no events fire, a fallback timeout ensures ready state is eventually set:
```
maxWaitTime = loadTimeCaptureDelay + readyForTrackingDelay + 2000ms
```

This handles edge cases like slow network connections or services that don't emit expected events.

### Video Loaded Validation

Before setting ready state, `isVideoLoaded()` validates the video is actually loaded:
```typescript
const isVideoLoaded = (): boolean => {
  const duration = video._streamKeysGetDuration?.() ?? video.duration;
  return duration > 0 && !isNaN(duration);
};
```

**Important:** Uses augmented `_streamKeysGetDuration()` to support Disney+ where native `video.duration` is unreliable (buffer-relative). Falls back to native duration for other services.

### Capture Window Behavior

The `handleVideoReady` function handles two scenarios:

1. **Within capture window** (`elapsed <= loadTimeCaptureDelay`):
   - Waits for `remainingDelay` (time until window closes)
   - Attempts to capture load time position if >= 15 seconds
   - Sets ready flag after additional `readyForTrackingDelay`

2. **Past capture window**:
   - Sets ready flag immediately
   - Does NOT attempt load time capture

### State Flags and Variables

| Name | Location | Purpose |
|------|----------|---------|
| `readyScheduled` | local variable | Prevents duplicate scheduling |
| `_streamKeysReadyForTracking` | video element | Enables seek position saving |
| `fallbackTimeout` | local variable | Fallback timeout reference |
| `captureDelayTimeout` | local variable | Capture delay timeout reference |
| `readyDelayTimeout` | local variable | Ready delay timeout reference |

### Fallback Timeout Cleanup

The fallback timeout is cleared when:
- Event-based trigger succeeds (`readyScheduled` set)
- Video is already ready (`_streamKeysReadyForTracking` true)
- Cleanup function is called (new video detected)

## Load Time Position Capture

Capture happens within the load time capture window:
1. Wait `loadTimeCaptureDelay` (default: 1000ms) for player to settle
2. Only capture if position >= 15 seconds
3. Mark video ready for tracking after `readyForTrackingDelay` (default: 500ms)

## Video Change Detection

History is automatically cleared when navigating to a new video:

- **Tracked state**: Current video element AND its source/content ID
- **Detection**: Runs every 1 second via `setupInterval`
- **Triggers**:
  - Different video element (HBO Max pattern: new DOM element for each video)
  - Same video element with different source (Disney+ pattern: blob URL changes)
  - Same video element with different content ID (BBC pattern: URL-based ID changes)

### New Video Detection Flow

1. `index.ts` detects new video (element OR content ID OR source change)
2. Calls cleanup function from previous `setupTracking()`:
   - Removes event listeners (`canplay`, `playing`, `loadeddata`, `seeked`, `seeking`, `timeupdate`)
   - Clears all pending timeouts (`fallbackTimeout`, `captureDelayTimeout`, `readyDelayTimeout`)
   - Stops RAF tracking loop
3. Resets `_streamKeysSeekListenerAdded = false` on old video
4. Calls `PositionHistory.reset(state)` to clear history state
5. Calls `setupTracking()` which:
   - Resets `_streamKeysReadyForTracking = false` and `_streamKeysPlaybackStarted = false`
   - Initializes fresh local variables (`readyScheduled = false`, timeout refs = null)
   - Sets up new event listeners and schedules new fallback timeout

### Video Element Flag Lifecycle

| Flag | Location | Reset When | Purpose |
|------|----------|------------|---------|
| `_streamKeysSeekListenerAdded` | video element | New video detected (index.ts) | Prevents duplicate listeners |
| `_streamKeysReadyForTracking` | video element | Start of setupTracking() | Enables seek position saving |
| `_streamKeysPlaybackStarted` | video element | Start of setupTracking() | Tracks if playback has started |
| `_streamKeysStableTime` | video element | Re-initialized in setupTracking() | Delayed time (pre-seek safe) |
| `_streamKeysLastKnownTime` | video element | Re-initialized in setupTracking() | Current time |

## User Saved Position (S Key)

- Press S to save current video position
- **Always saves** regardless of position (no SEEK_MIN_DIFF_SECONDS check)
- Only one user-saved position is stored; S overwrites the previous one
- Appears as first item in the history section (after load time separator)
- Has green-tinted styling to distinguish from other positions
- **Key number is always "1"** (reserved), pushing history items to start at "2"
- Key "0" is reserved for load time (even if load time is not present)
- If no user saved position, history items start at "1"
- Shows "saved position" as label (not relative time)

## Dialog State Management

### Toggle Behavior
- Pressing R when dialog is open closes it
- Pressing R when closed opens it
- ESC key closes dialog and prevents fullscreen exit

### Key Handling in Dialog
- Number keys 0-4 select corresponding position (load time + user saved + up to 3 history)
- R or ESC closes dialog
- Modifier keys (Cmd, Ctrl) pass through for browser shortcuts

### Real-time Updates
- Current time display updates every 300ms
- Relative time ("2m 30s ago") updates live
- Use `tabular-nums` for stable number widths

## Video Time Tracking

### Two-Timestamp System with Delayed Capture

For services like Disney+ where the UI updates before `video.seeking` becomes true, we use a two-timestamp system:

- `_streamKeysLastKnownTime`: Always current, updated every RAF frame
- `_streamKeysStableTime`: Delayed by ~500ms, guaranteed to be pre-seek value

The stable time is updated using delayed capture with `setTimeout`:
```typescript
const track = () => {
  const newTime = getActualPlaybackTime(currentVideo);
  currentVideo._streamKeysLastKnownTime = newTime;

  // Schedule stable time update with captured value (every ~200ms)
  if (now - lastStableSchedule >= STABLE_TIME_SCHEDULE_INTERVAL_MS) {
    const capturedTime = newTime; // Frozen at this moment
    setTimeout(() => {
      currentVideo._streamKeysStableTime = capturedTime; // Used 500ms later
    }, STABLE_TIME_DELAY_MS);
    lastStableSchedule = now;
  }
  requestAnimationFrame(track);
};
```

The key insight: the value passed to `setTimeout` is captured at scheduling time, not read when the timeout fires. This eliminates race conditions where the UI updates before `video.seeking` becomes true.

After seek completes (`seeked` event), only `_streamKeysLastKnownTime` is synced to the current position. The `_streamKeysStableTime` is NOT updated by the `seeked` handler - the RAF loop will update it with the proper 500ms delay, ensuring it always reflects a position from before any potential new seek.

### Getting Pre-Seek Position

Use `_streamKeysGetStableTime()` method which provides consistent fallback:
```typescript
video._streamKeysGetStableTime = () => {
  return video._streamKeysStableTime ??
         video._streamKeysLastKnownTime ??
         video._streamKeysGetPlaybackTime?.() ??
         video.currentTime;
};
```

This method is used by both keyboard seeks and timeline/UI seeks for consistent behavior.

### Video Element Properties

- `_streamKeysLastKnownTime`: Current position (updated every frame)
- `_streamKeysStableTime`: Delayed position (~500ms behind, pre-seek safe)
- `_streamKeysGetPlaybackTime()`: Returns actual playback time (uses custom logic for services like Disney+)
- `_streamKeysGetStableTime()`: Returns stable time with fallback chain
- `_streamKeysSeekListenerAdded`: Prevents duplicate listeners
- `_streamKeysReadyForTracking`: True after initial load complete

## Exported Constants

```typescript
import {
  PositionHistory,
  SEEK_MAX_HISTORY,      // 3 - max entries in history
  SEEK_MIN_DIFF_SECONDS, // 15 - min seconds between positions
  SEEK_DEBOUNCE_MS       // 5000 - debounce window for rapid seeks
} from './history';

// Public API methods:
// - PositionHistory.createState() - create new state object
// - PositionHistory.reset(state) - reset state for new video
// - PositionHistory.save(state, time) - direct save, no debounce
// - PositionHistory.record(state, time) - save with debounce
// - PositionHistory.saveUserPosition(state, time) - save user position (S key), overwrites previous
// - PositionHistory.debouncedSave(state, time) - returns true if debounced, false if save attempted
```
